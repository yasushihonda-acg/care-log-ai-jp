
# 機能仕様詳細

## 1. AI解析ロジック (Pro-Model Reasoning)

本アプリでは、複雑な自然言語入力を正確に構造化データへ変換するため、推論能力に優れた **「Gemini 2.5 Pro」** を採用します。

### 採用モデル: Gemini 2.5 Pro
*   **選定理由:** Flashモデルでは困難だった「複合データの分離（例：お茶200ml）」や「文脈の深い理解」を、高い推論能力によって解決するため。
*   **戦略:** モデルの地力が高いため、過度なパラメータ調整（Thinking Config等）は行わず、**「Chain of Thought (思考の連鎖)」** を促すプロンプトエンジニアリングで精度を担保します。

### 基本方針: Metadata-Driven Extraction (メタデータ駆動抽出)
AIに対して、単なるラベル名だけでなく、各フィールドの「定義（Description）」を渡すことで、曖昧さを排除します。

*   **構造:** `key`, `label` に加えて `description` を保持。
*   **例:**
    *   `fluid_type`: "水分の名称のみ（例：お茶）。量は絶対に入れないこと"
    *   `fluid_ml`: "量のみを入れること"

### 戦略1: Settings Hydration (設定データのメタデータ注入)
**重要:** ブラウザに保存されているユーザーの古い設定データには、AIへの指示（`description`）が含まれていません。
これを解決するため、アプリ起動時に以下のロジックでデータを同期します。

1.  `localStorage` からユーザー設定を読み込む。
2.  `DEFAULT_FIELD_SETTINGS`（マスター）と比較する。
3.  キーが一致する項目があれば、マスター側の `description` をユーザー設定に注入（マージ）する。
4.  これにより、既存ユーザーも即座にAI精度向上の恩恵を受けられる。

### 戦略2: Chain of Thought & Ambiguity Resolution
AIはJSONを生成する前に、必ず `thought` フィールドで思考プロセスを出力します。これにより、いきなり答えを出そうとして失敗するのを防ぎます。

**シミュレーション済みパターン (Gemini 2.5 Pro):**

**パターンA: 水分摂取の分離**
*   **Input:** "お昼ご飯は全粥を8割、お茶を200ml飲みました。"
*   **Reasoning:**
    1.  食事内容「全粥」、量「8割」を認識。
    2.  水分内容「お茶」、量「200ml」を認識。
    3.  フィールド定義を確認。`fluid_type`は名称のみ、`fluid_ml`は数値のみ。
    4.  分離を実行。
*   **Output:**
    ```json
    {
      "fluid_type": "お茶",
      "fluid_ml": "200"
    }
    ```

## 2. 動的フィールド設定 (Settings)

施設や利用者ごとに記録したい項目が異なるため、フィールド定義をユーザーがカスタマイズ可能です。

### データ管理
*   **保存場所:** ブラウザの `localStorage` (`care_log_field_settings`)。
*   **構造:** `types.ts` の `FieldSetting` インターフェース準拠。
*   **拡張:** ユーザーがカスタム項目を追加した場合、現時点では `description` は空ですが、将来的にユーザーが説明を入力できるUIへの拡張を想定しています。

## 3. RAGチャット (Context Injection)

Geminiの広大なコンテキストウィンドウを活かした簡易RAGを実装しています。

### 仕組み
1.  ユーザーが質問する。
2.  サーバー側で `SELECT * FROM care_records ORDER BY recorded_at DESC LIMIT 50` を実行。
3.  取得したJSONデータをそのままプロンプトの `System Instruction` に埋め込む。

### 利点と制約
*   **利点:** 実装コストが低く、ハルシネーションが起きにくい。
*   **制約:** 直近50件のデータのみ参照。

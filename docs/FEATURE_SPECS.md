
# 機能仕様詳細

## 1. AI解析ロジック (ハイブリッド設計)

本アプリでは、AIによる入力補助の成功率を最大化するため、「厳密な型定義」よりも「柔軟な受け入れ」を優先する設計を採用しています。

### 基本方針: Loose Schema & Frontend Validation
1.  **Backend (API/AI)**:
    *   `api/parse.ts` では、すべての詳細フィールドを `STRING` 型として定義します。
    *   プロンプトでも「無理な変換はせず、ユーザーの言ったことをそのまま抽出して」と指示します。
    *   これにより、AIは「80%」「36.5度」「少し」といった自然言語をそのままJSONに入れて返すことができ、パースエラーを回避します。
2.  **Frontend**:
    *   受け取ったデータをそのまま入力フォームに表示します。
    *   必要であれば、統計画面での集計時に数値変換（`parseInt`など）を行います。

### 戦略1: Chain of Thought (思考の連鎖)
解析精度を劇的に向上させるため、AIはいきなり結果を出力せず、**「まず思考し、その後にデータをマッピングする」** プロセスを踏みます。

*   **Thoughtプロセス**: 入力文を分析し、「何が含まれているか」「複合データはないか」を自然言語で整理します。
*   **Mappingプロセス**: 思考に基づき、JSONを生成します。

### 戦略2: Ambiguity Resolution (曖昧性解消)
特に「水分摂取」や「バイタル」において、複数の情報が混ざった入力を正しく分離するためのルールを定義します。

**分離ルール:**
*   **複合値の分離**: 「お茶200」のように数値と名詞が隣接している場合、これらを「種類(fluid_type)」と「量(fluid_ml)」に分離する。
*   **文脈推論**: 単位がない場合でも、文脈（「飲んだ」など）から判断する。

### Few-Shot Prompting (具体的な学習データ)
以下のパターンをAIに学習させ、同様の構造化を行わせます。

**パターンA: Chain of Thought適用**
*   **入力:** 「お昼は全粥8割で、お茶を200ml飲みました」
*   **思考(Thought):** "食事の記録です。主食は全粥で摂取率は8割。水分摂取もあり、種類はお茶、量は200mlと明言されています。"
*   **出力:** 
    ```json
    {
      "record_type": "meal",
      "details": {
        "main_dish": "全粥",
        "amount_percent": "8割",
        "fluid_type": "お茶",
        "fluid_ml": "200ml"
      }
    }
    ```

**パターンB: 曖昧なバイタル記録**
*   **入力:** "熱は36.8、血圧124の78"
*   **思考(Thought):** "バイタル記録です。'熱'は体温、'36.8'が値。'血圧'は上が124、下が78と推測されます。"
*   **出力:** `temperature: "36.8"`, `systolic_bp: "124"`, `diastolic_bp: "78"`

## 2. 動的フィールド設定 (Settings)

施設や利用者ごとに記録したい項目が異なるため、フィールド定義をユーザーがカスタマイズ可能です。

### データ管理
*   **保存場所:** ブラウザの `localStorage` (`care_log_field_settings`)。
*   **構造:** 記録タイプごとの配列。
    ```typescript
    {
      "meal": [
        { "key": "main_dish", "label": "主食" },
        { "key": "f_autogen_123", "label": "特別食" } // カスタム項目
      ]
    }
    ```

### システムキーの自動生成
*   ユーザーは「ラベル名（日本語）」のみを入力します。
*   システム内部で使用する `key` は、追加時に自動生成されます（例: `f_<timestamp>_<random>`）。
*   これにより、ユーザーが英語のキー名を管理する負担をなくし、かつキーの重複を防ぎます。

### AIとの連携
*   解析リクエスト時に、この「フィールド設定（キーとラベルのペア）」をAIに送信します。
*   AIは「ラベル」をヒントにして、抽出した情報を適切な「キー」にマッピングします。

## 3. RAGチャット (Context Injection)

複雑なベクトルデータベースを使用せず、Gemini 2.5の広大なコンテキストウィンドウを活かした簡易RAGを実装しています。

### 仕組み
1.  ユーザーが質問する。
2.  サーバー側で `SELECT * FROM care_records ORDER BY recorded_at DESC LIMIT 50` を実行。
3.  取得したJSONデータをそのままプロンプトの `System Instruction` に埋め込む（Context Injection）。
4.  「上記データを事実として回答せよ」と指示する。

### 利点
*   **実装コスト低:** ベクトルDBやEmbeddings処理が不要。
*   **即時性:** DBに保存された瞬間から検索対象になる。
*   **精度:** 生データをそのまま渡すため、ハルシネーション（嘘）が起きにくい。

### 制約
*   **データ量:** 一度に渡せるトークン数に限りがあるため、現在は直近50件に限定。
